(() => {
  // ---------- Helpers ----------
  const $ = sel => document.querySelector(sel);
  const norm = s => (s||'').toLowerCase().trim()
    .replace(/[.,;:!?]/g,'')
    .replace(/√ü/g,'ss').replace(/√§/g,'ae').replace(/√∂/g,'oe').replace(/√º/g,'ue')
    .replace(/\s+/g,' ');
  const shuffle = arr => {
    const a = [...arr];
    for(let i=a.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; }
    return a;
  };

  ---------- Data (AUTOGENERATED from Excel) ----------
  const CARDS = [
    { en'in the vicinity of', de'in der N√§he von', sol[
          'in der N√§he von'
        ] },
    { en'to like (something)', de'gefallen (etwas)', sol[
          'gefallen (etwas)',
          'gefallen',
          'gefallen etwas'
        ] },
    { en'to consist (of something)', de'(aus etwas) bestehen', sol[
          'aus etwas bestehen',
          'bestehen',
          '(aus etwas) bestehen'
        ] },
    { en'should', de'sollst = sollen', sol[
          'sollst',
          'sollen'
        ] },
    { en'must', de'must = m√ºssen', sol[
          'must',
          'm√ºssen'
        ] },
    { en'I must inform you', de'Ich muss Sie informieren', sol[
          'Ich muss Sie informieren'
        ] },
    { en'previous', de'vorherig', sol[
          'vorherig'
        ] },
    { en'earliest', de'fr√ºhestens', sol[
          'fr√ºhestens'
        ] },
    { en'from', de'von', sol[
          'von'
        ] },
    { en'from home', de'von zu Hause', sol[
          'von zu Hause'
        ] },
    { en'to do', de'tun', sol[
          'tun'
        ] },
    { en'what a company does for the health of its employees', de'was eine Firma f√ºr die Gesundheit ihrer Mitarbeiter tut', sol[
          'was eine Firma f√ºr die Gesundheit ihrer Mitarbeiter tut'
        ] },
    { en'to taste', de'schmecken', sol[
          'schmecken'
        ] },
    { en'it tastes good', de'Es schmeckt gut', sol[
          'Es schmeckt gut'
        ] },
    { en'everywhere', de'√ºberall', sol[
          '√ºberall'
        ] },
    { en'to receive', de'bekommen', sol[
          'bekommen'
        ] },
    { en'to become', de'werden', sol[
          'werden'
        ] },
    { en'the company', de'die Firma', sol[
          'die Firma'
        ] },
    { en'to miss', de'fehlen', sol[
          'fehlen'
        ] },
    { en'in the past (for this sentence)', de'fr√ºher', sol[
          'fr√ºher'
        ] },
    { en'for that', de'daf√ºr', sol[
          'daf√ºr'
        ] },
    { en'I have no time for that', de'Ich habe keine Zeit daf√ºr', sol[
          'Ich habe keine Zeit daf√ºr'
        ] },
    { en'I have no space for that', de'Ich habe keinen Platz daf√ºr', sol[
          'Ich habe keinen Platz daf√ºr'
        ] },
    { en'after', de'danach', sol[
          'danach'
        ] },
    { en'to feel', de'(sich) f√ºhlen', sol[
          'sich f√ºhlen',
          'f√ºhlen',
          '(sich) f√ºhlen'
        ] },
    { en'there', de'dort', sol[
          'dort'
        ] },
    { en'there', de'da', sol[
          'da'
        ] },
    { en'besides that  furthermore', de'au√üerdem', sol[
          'au√üerdem'
        ] },
    { en'fresh vegetables', de'frisches Gem√ºse', sol[
          'frisches Gem√ºse'
        ] },
    { en'to laugh', de'lachen', sol[
          'lachen'
        ] },
    { en'to clean', de'putzen', sol[
          'putzen'
        ] },
    { en'difficult', de'schwierig', sol[
          'schwierig'
        ] },
    { en'rather  pretty  fairly', de'ziemlich', sol[
          'ziemlich'
        ] },
    { en'to change', de'sich √§ndern', sol[
          'sich √§ndern'
        ] },
    { en'to try', de'versuchen (etwas)', sol[
          'versuchen (etwas)',
          'versuchen etwas',
          'versuchen'
        ] },
    { en'to call', de'anrufen', sol[
          'anrufen'
        ] },
    { en'the dish', de'das Gericht', sol[
          'das Gericht'
        ] },
    { en'before  previously (in terms of time)', de'vorher', sol[
          'vorher'
        ] },
    { en'never (before)', de'noch nie', sol[
          'noch nie'
        ] },
    { en'all the time  constantly', de'dauernd', sol[
          'dauernd'
        ] },
    { en'absolutely  under any circumstance', de'unbedingt', sol[
          'unbedingt'
        ] },
    { en'a few  a little (quantity)', de'wenig', sol[
          'wenig'
        ] },
    { en'little (description)', de'klein', sol[
          'klein'
        ] },
    { en'order (rarely reserve)', de'bestellen', sol[
          'bestellen'
        ] },
    { en'to open up', de'aufmachen', sol[
          'aufmachen'
        ] },
    { en'clear', de'klar', sol[
          'klar'
        ] },
    { en'maybe', de'vielleicht', sol[
          'vielleicht'
        ] },
    { en'rich', de'reich', sol[
          'reich'
        ] },
  ];  49 items

  // ---------- State & Elements ----------
  let deck=[], idx=-1, answered=0, ok=0, bad=0, locked=false, awaitNext=false;
  const history=[];
  const el = {
    card: $('#card'), cardText: $('#card-text'), cardHint: $('#card-hint'),
    startRow: $('#start-row'), startBtn: $('#start-btn'), fx: $('#fx'),
    input: $('#answer-input'), submit: $('#submit-btn'), reveal: $('#reveal-btn'), skip: $('#skip-btn'),
    feedback: $('#feedback'), counter: $('#counter'), bar: $('#bar-fill'),
    bucketOk: $('#bucket-correct'), bucketBad: $('#bucket-wrong'),
    results: $('#results'), restart: $('#restart-btn'), form: $('#answer-form')
  };

  // ---------- UI helpers ----------
  function enableInputs(v){
    el.input.disabled = el.submit.disabled = el.reveal.disabled = el.skip.disabled = !v;
    if(v) el.input.focus();
  }
  function updateProgress(){
    const safe = Math.min(answered, CARDS.length);
    el.counter.textContent = `${safe} / ${CARDS.length}`;
    const pct = Math.round((safe/CARDS.length)*100);
    el.bar.style.width = pct + '%';
  }
  function showWord(){
    const c = deck[idx];
    el.cardText.textContent = c.en;
    el.cardHint.textContent = '';      // Hinweis ausblenden
    awaitNext = false;
    el.input.value = ''; el.feedback.innerHTML = '';
    if(el.fx) el.fx.innerHTML = '';    // altes Bild weg
    enableInputs(true);
  }
  function nextCard(){
    idx++;
    if(idx >= deck.length){ finish(); return; }
    showWord();
  }
  function addMiniCard(to, card, isOk){
    const d = document.createElement('div');
    d.className = 'mini-card ' + (isOk? 'ok':'bad');
    d.innerHTML = `<div class="en">${card.en}</div><div class="de">${card.de}</div>`;
    to.appendChild(d);
  }
  const pretty = card => card.de.split('|').join(' / ');
  function firstLetter(card){
    let variant = card.de.split('/')[0].split('|')[0].trim();
    const lower = variant.toLowerCase();
    if(lower.startsWith('der ')) variant = variant.slice(4);
    else if(lower.startsWith('die ')) variant = variant.slice(4);
    else if(lower.startsWith('das ')) variant = variant.slice(4);
    for(const ch of variant){ if(/[a-zA-Z√§√∂√º√Ñ√ñ√ú√ü]/.test(ch)) return ch.toUpperCase(); }
    return '';
  }
  function showSolution(card){
    el.cardText.textContent = pretty(card); // DE-L√∂sung anzeigen
    el.cardHint.textContent = 'Dr√ºcke ENTER um zum n√§chsten Wort zu gelangen';
    awaitNext = true;
  }
  function showFx(kind){
    if(!el.fx) return;
    const src = kind==='ok' ? 'https://i.imgur.com/RQ3mDTH.png'
                            : 'https://i.imgur.com/9BACXIX.png';
    el.fx.innerHTML = '';
    const img = document.createElement('img');
    img.src = src; img.alt = kind; img.className = 'pop-img';
    el.fx.appendChild(img);
    img.addEventListener('animationend', ()=>{ if(el.fx.contains(img)) el.fx.removeChild(img); });
  }

  // ---------- Core ----------
  function checkAnswer(){
    if(locked || idx < 0) return;
    locked = true;

    const userRaw = el.input.value.trim();
    const user = norm(userRaw);
    const card = deck[idx];
    const solutions = (card.sol || card.de.split('|')).map(norm);
    const correct = solutions.includes(user);

    enableInputs(false);

    if(correct){ ok++; answered++; el.feedback.innerHTML = `<span class="ok">‚úÖ Richtig!</span>`; addMiniCard(el.bucketOk, card, true); showFx('ok'); }
    else { bad++; answered++; el.feedback.innerHTML = `<span class="bad">‚ùå Falsch.</span> Richtig: <strong>${pretty(card)}</strong>`; addMiniCard(el.bucketBad, card, false); showFx('bad'); }

    history.push({en:card.en, de:card.de, input:userRaw||'‚Äî', correct});
    updateProgress();

    locked = false;
    showSolution(card); // warten auf ENTER
  }

  function renderResults(){
    const right = history.filter(h=>h.correct);
    const wrong = history.filter(h=>!h.correct);
    const table = (list,title)=>{
      const rows = list.map(h=>`<tr><td>${h.en}</td><td>${h.de}</td><td>${h.input||'‚Äî'}</td></tr>`).join('');
      return `<div class="res-card"><h3>${title} (${list.length})</h3><table><thead><tr><th>EN</th><th>DE (L√∂sung)</th><th>Eingabe</th></tr></thead><tbody>${rows || '<tr><td colspan="3">‚Äî</td></tr>'}</tbody></table></div>`;
    };
    el.results.innerHTML = table(right,'Richtig') + table(wrong,'Falsch');
    el.results.classList.add('show');
  }

  function start(){
    if(idx >= 0) return;           // bereits gestartet
    deck = shuffle(CARDS);
    idx = -1; answered = ok = bad = 0; locked = false; awaitNext = false;
    history.length = 0;
    el.bucketOk.innerHTML = ''; el.bucketBad.innerHTML = '';
    el.results.classList.remove('show'); el.results.innerHTML='';
    if(el.startRow) el.startRow.style.display = 'none';
    updateProgress(); enableInputs(true); nextCard();
  }

  function finish(){
    enableInputs(false);
    el.cardText.textContent = 'Fertig!';
    el.cardHint.textContent = `Ergebnis: ${ok} ‚úÖ ¬∑ ${bad} ‚ùå`;
    el.feedback.innerHTML = '';
    renderResults();
    el.restart.style.display = 'inline-block';
    awaitNext = false;
  }

  // ---------- Events ----------
  document.addEventListener('DOMContentLoaded', () => {
    // Start
    el.startBtn.addEventListener('click', start);
    // Enter/S startet; Enter w√§hrend awaitNext => n√§chste Karte
    document.addEventListener('keydown', (e)=>{
      if(idx < 0 && (e.key === 'Enter' || e.key.toLowerCase() === 's')) { e.preventDefault(); start(); return; }
      if(awaitNext && e.key === 'Enter'){ e.preventDefault(); awaitNext=false; nextCard(); }
    });
    // Extra: Klick irgendwo auf Karte startet ebenfalls
    el.card.addEventListener('click', ()=>{ if(idx < 0) start(); });

    // Training
    el.form.addEventListener('submit', (e)=>{ e.preventDefault(); checkAnswer(); });
    el.reveal.addEventListener('click', ()=>{
      if(idx < 0 || awaitNext) return;
      const letter = firstLetter(deck[idx]);
      el.feedback.innerHTML = `üí° Anfangsbuchstabe: <strong>${letter}</strong>`;
      el.input.focus();
    });
    el.skip.addEventListener('click', ()=>{
      if(locked || idx < 0) return; locked = true; enableInputs(false);
      const c = deck[idx];
      el.feedback.innerHTML = `<span class="bad">‚è≠ √úbersprungen.</span>`;
      if(answered < CARDS.length){ bad++; answered++; }
      addMiniCard(el.bucketBad, c, false);
      history.push({en:c.en, de:c.de, input:'(√ºbersprungen)', correct:false});
      updateProgress();
      locked = false;
      showSolution(c); showFx('bad'); // warten auf ENTER
    });
    el.restart.addEventListener('click', ()=>{
      idx = -1;
      if(el.startRow) el.startRow.style.display = 'flex';
      el.cardText.textContent = 'Vokabel-Trainer';
      el.cardHint.textContent = 'Klicke auf Start, dann erscheint ein englisches Wort. Tipp die deutsche √úbersetzung (mit Artikel) ein und dr√ºcke Enter.';
      el.restart.style.display = 'none'; enableInputs(false);
      el.input.value = ''; el.feedback.innerHTML = ''; el.results.classList.remove('show'); el.results.innerHTML='';
      if(el.fx) el.fx.innerHTML = '';
      updateProgress();
    });

    // Komfort
    document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') el.input.blur(); if(e.key === 'ArrowUp') el.input.focus(); });

    // Init
    enableInputs(false); updateProgress();
  });
})();

